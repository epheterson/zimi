name: Desktop Release

on:
  push:
    tags: ['v*.*.*']
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build (e.g. v1.3.0)'
        required: false

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            artifact: Zimi-Linux-amd64
            asset: Zimi-Linux-amd64.AppImage
          - os: macos-15-intel
            artifact: Zimi-Intel
            asset: Zimi-Intel.dmg
          - os: macos-latest
            artifact: Zimi-AppleSilicon
            asset: Zimi-AppleSilicon.dmg

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgirepository-2.0-dev \
            gir1.2-gtk-3.0 \
            gir1.2-webkit2-4.1 \
            gcc libcairo2-dev pkg-config python3-dev

      - name: Install dependencies
        run: pip install -r requirements-desktop.txt

      - name: Install PyGObject (Linux)
        if: runner.os == 'Linux'
        run: pip install PyGObject

      - name: Install pytest
        run: pip install pytest

      # ── Pre-build tests ──────────────────────────────────────────────

      - name: Run unit tests
        run: python tests/test_unit.py

      - name: Run integration tests
        run: python -m pytest tests/test_server.py -v

      # ── Build ─────────────────────────────────────────────────────────

      - name: Download Sparkle.framework (macOS)
        if: runner.os == 'macOS'
        run: |
          curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz" -o /tmp/sparkle.tar.xz
          tar -xf /tmp/sparkle.tar.xz -C /tmp
          cp -R /tmp/Sparkle.framework Sparkle.framework
          echo "Sparkle.framework ready ($(du -sh Sparkle.framework | cut -f1))"

      - name: Generate icons
        run: python zimi/assets/generate_icons.py

      - name: Inspect libzim package
        shell: bash
        run: |
          python -c "import libzim; print('libzim OK')"
          python -c "
          import importlib.util, os, sysconfig
          spec = importlib.util.find_spec('libzim')
          print(f'libzim origin: {spec.origin}')
          print(f'submodule_search_locations: {spec.submodule_search_locations}')
          for base in [sysconfig.get_path('purelib'), sysconfig.get_path('platlib')]:
              d = os.path.join(base, 'libzim')
              if os.path.isdir(d):
                  print(f'libzim dir ({d}):')
                  for f in sorted(os.listdir(d)):
                      full = os.path.join(d, f)
                      sz = os.path.getsize(full) if os.path.isfile(full) else '-'
                      print(f'  {f}  ({sz})')
          "

      - name: Build with PyInstaller
        run: pyinstaller --noconfirm zimi_desktop.spec

      # ── Post-build smoke tests ────────────────────────────────────────

      - name: Smoke test built binary (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          BINARY="dist/Zimi.app/Contents/MacOS/Zimi"
          TMPZIM=$(mktemp -d)
          echo "Starting Zimi with --serve --port 0 ..."
          $BINARY --serve --port 0 --zim-dir "$TMPZIM" > /tmp/zimi_out.txt 2>&1 &
          PID=$!

          # Wait for READY message (up to 30s)
          PORT=""
          for i in $(seq 1 60); do
            if grep -q "^READY " /tmp/zimi_out.txt 2>/dev/null; then
              PORT=$(grep "^READY " /tmp/zimi_out.txt | head -1 | awk '{print $2}')
              break
            fi
            sleep 0.5
          done

          if [ -z "$PORT" ]; then
            echo "ERROR: Server did not start within 30s"
            cat /tmp/zimi_out.txt
            kill $PID 2>/dev/null || true
            exit 1
          fi

          echo "Server ready on port $PORT"
          BASE="http://127.0.0.1:$PORT"

          # Hit endpoints
          echo "Testing /health..."
          curl -sf "$BASE/health" | python -c "import sys,json; d=json.load(sys.stdin); assert d['status']=='ok', f'Bad health: {d}'; print(f'  OK: v{d[\"version\"]}, {d[\"zim_count\"]} ZIMs')"

          echo "Testing /list..."
          curl -sf "$BASE/list" | python -c "import sys,json; d=json.load(sys.stdin); print(f'  OK: {len(d)} sources')"

          echo "Testing /search..."
          curl -sf "$BASE/search?q=test&limit=1&fast=1" | python -c "import sys,json; d=json.load(sys.stdin); assert 'results' in d; print(f'  OK: {d[\"total\"]} results')"

          echo "Testing /static/pdfjs/web/viewer.html..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/static/pdfjs/web/viewer.html")
          [ "$STATUS" = "200" ] && echo "  OK: pdf.js viewer" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "Testing /manage/status..."
          curl -sf "$BASE/manage/status" | python -c "import sys,json; d=json.load(sys.stdin); assert 'zim_count' in d; print(f'  OK: {d[\"zim_count\"]} ZIMs, manage={d[\"manage_enabled\"]}')"

          echo "Testing / (web UI)..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/")
          [ "$STATUS" = "200" ] && echo "  OK: web UI" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "All smoke tests passed!"
          kill $PID 2>/dev/null || true
          rm -rf "$TMPZIM"

      - name: Smoke test built binary (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          BINARY="dist/Zimi/Zimi"
          TMPZIM=$(mktemp -d)
          echo "Starting Zimi with --serve --port 0 ..."
          $BINARY --serve --port 0 --zim-dir "$TMPZIM" > /tmp/zimi_out.txt 2>&1 &
          PID=$!

          PORT=""
          for i in $(seq 1 60); do
            if grep -q "^READY " /tmp/zimi_out.txt 2>/dev/null; then
              PORT=$(grep "^READY " /tmp/zimi_out.txt | head -1 | awk '{print $2}')
              break
            fi
            sleep 0.5
          done

          if [ -z "$PORT" ]; then
            echo "ERROR: Server did not start within 30s"
            cat /tmp/zimi_out.txt
            kill $PID 2>/dev/null || true
            exit 1
          fi

          echo "Server ready on port $PORT"
          BASE="http://127.0.0.1:$PORT"

          echo "Testing /health..."
          curl -sf "$BASE/health" | python -c "import sys,json; d=json.load(sys.stdin); assert d['status']=='ok'; print(f'  OK: v{d[\"version\"]}')"

          echo "Testing /static/pdfjs/web/viewer.html..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/static/pdfjs/web/viewer.html")
          [ "$STATUS" = "200" ] && echo "  OK: pdf.js viewer" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "Testing / (web UI)..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/")
          [ "$STATUS" = "200" ] && echo "  OK: web UI" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "All smoke tests passed!"
          kill $PID 2>/dev/null || true
          rm -rf "$TMPZIM"

      # ── Packaging ─────────────────────────────────────────────────────

      - name: Build Snap (Linux)
        if: runner.os == 'Linux'
        uses: snapcore/action-build@v1
        with:
          snapcraft-args: '--destructive-mode'

      - name: Upload Snap artifact
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: Zimi-Linux-snap
          path: "*.snap"

      - name: Package AppImage (Linux)
        if: runner.os == 'Linux'
        run: |
          # Build AppDir from PyInstaller output
          APPDIR=dist/Zimi.AppDir
          mv dist/Zimi "$APPDIR"

          # Add AppImage metadata
          cp linux/AppRun "$APPDIR/"
          chmod +x "$APPDIR/AppRun"
          cp linux/zimi.desktop "$APPDIR/"
          cp zimi/assets/icon.png "$APPDIR/zimi.png"
          ln -sf zimi.png "$APPDIR/.DirIcon"

          # Download appimagetool
          curl -sL "https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage" -o /tmp/appimagetool
          chmod +x /tmp/appimagetool

          # Build the AppImage (--appimage-extract-and-run avoids FUSE requirement in CI)
          ARCH=x86_64 /tmp/appimagetool --appimage-extract-and-run "$APPDIR" "${{ matrix.asset }}"

      - name: Install create-dmg (macOS)
        if: runner.os == 'macOS'
        run: brew install create-dmg

      - name: Import signing certificate (macOS)
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE_BASE64 != ''
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -hex 12)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

      - name: Copy Sparkle.framework into app bundle (macOS)
        if: runner.os == 'macOS'
        run: |
          # Must copy AFTER PyInstaller — BUNDLE() overwrites dist/Zimi.app
          FWDIR="dist/Zimi.app/Contents/Frameworks"
          mkdir -p "$FWDIR"
          rm -rf "$FWDIR/Sparkle.framework"
          cp -R Sparkle.framework "$FWDIR/"

          # Remove XPC services — not needed for non-sandboxed apps, and they
          # fail to launch from inside a PyInstaller bundle ("updater failed to start")
          rm -rf "$FWDIR/Sparkle.framework/Versions/B/XPCServices"
          echo "Copied Sparkle.framework (XPC services removed for non-sandboxed app)"
          ls -la "$FWDIR/Sparkle.framework/Versions/Current/Sparkle"

      - name: Code sign app (macOS)
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE_BASE64 != ''
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Use whatever signing identity is in the keychain
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | head -1 | sed 's/.*"\(.*\)"/\1/')
          echo "Signing with: $IDENTITY"

          # Sign Sparkle.framework's nested binaries first
          SPARKLE="dist/Zimi.app/Contents/Frameworks/Sparkle.framework"
          if [ -d "$SPARKLE" ]; then
            # Sign Autoupdate (XPC service inside Sparkle)
            find "$SPARKLE" -type f \( -name "*.xpc" -o -name "Autoupdate" -o -name "Updater" \) -exec \
              codesign --force --options runtime --sign "$IDENTITY" --timestamp {} \;
            # Sign the framework binary itself
            codesign --force --options runtime --sign "$IDENTITY" --timestamp "$SPARKLE/Versions/Current/Sparkle"
            codesign --force --options runtime --sign "$IDENTITY" --timestamp "$SPARKLE"
          fi

          # Sign all binaries inside the app bundle
          find dist/Zimi.app -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.pyd" \) -exec \
            codesign --force --options runtime --sign "$IDENTITY" --timestamp {} \;

          # Sign the main executable
          codesign --force --options runtime --sign "$IDENTITY" --timestamp dist/Zimi.app/Contents/MacOS/Zimi

          # Sign the app bundle itself
          codesign --force --deep --options runtime --sign "$IDENTITY" --timestamp dist/Zimi.app

          # Verify
          codesign --verify --deep --strict dist/Zimi.app
          echo "Code signing successful"

      - name: Package (macOS)
        if: runner.os == 'macOS'
        working-directory: dist
        run: |
          create-dmg \
            --volname "Zimi" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "Zimi.app" 150 185 \
            --app-drop-link 450 185 \
            --no-internet-enable \
            ../${{ matrix.asset }} Zimi.app

      - name: Notarize DMG (macOS)
        if: runner.os == 'macOS' && env.APPLE_ID != ''
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Submitting for notarization..."
          xcrun notarytool submit ${{ matrix.asset }} \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait --timeout 10m

          echo "Waiting for notarization ticket to propagate..."
          sleep 15

          echo "Stapling notarization ticket..."
          for i in 1 2 3; do
            xcrun stapler staple ${{ matrix.asset }} && break
            echo "Staple attempt $i failed, retrying in 15s..."
            sleep 15
          done
          echo "Notarization complete"

      - name: Move asset to dist
        run: mv ${{ matrix.asset }} dist/ 2>/dev/null || true
        shell: bash

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: dist/${{ matrix.asset }}

  release:
    needs: build
    runs-on: macos-latest  # Need macOS for Sparkle sign_update tool

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4

      # ── Sparkle EdDSA signing + appcast ─────────────────────────────
      - name: Sign DMGs and update appcast.xml
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "SPARKLE_PRIVATE_KEY not set, skipping DMG signing"
            exit 0
          fi

          # Download Sparkle tools
          curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz" -o /tmp/sparkle.tar.xz
          tar -xf /tmp/sparkle.tar.xz -C /tmp

          TAG="${{ github.event.inputs.tag || github.ref_name }}"
          VERSION="${TAG#v}"
          REPO="epheterson/Zimi"

          # Sign both DMGs and generate per-architecture appcasts
          generate_appcast() {
            local ARCH_NAME="$1" DMG_DIR="$2" DMG_ASSET="$3" OUTFILE="$4"
            local DMG_FILE=$(ls "$DMG_DIR"/*.dmg 2>/dev/null | head -1)
            if [ -z "$DMG_FILE" ]; then
              echo "WARNING: No $ARCH_NAME DMG found in $DMG_DIR"
              return 1
            fi

            echo "Signing $DMG_FILE ($ARCH_NAME)..."
            local SIG=$(/tmp/bin/sign_update "$DMG_FILE" --ed-key-file <(echo "$SPARKLE_PRIVATE_KEY") 2>&1)
            local ED_SIG=$(echo "$SIG" | grep -o 'sparkle:edSignature="[^"]*"' | sed 's/sparkle:edSignature="//;s/"//')
            local LENGTH=$(echo "$SIG" | grep -o 'length="[^"]*"' | sed 's/length="//;s/"//')

            if [ -z "$ED_SIG" ]; then
              echo "ERROR: Failed to sign $ARCH_NAME DMG"
              return 1
            fi

            cat > "$OUTFILE" << APPCAST
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Zimi Updates</title>
              <link>https://github.com/${REPO}</link>
              <description>Offline knowledge server for ZIM files</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <sparkle:version>${VERSION}</sparkle:version>
                <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>12.0</sparkle:minimumSystemVersion>
                <pubDate>$(date -R)</pubDate>
                <enclosure
                  url="https://github.com/${REPO}/releases/download/${TAG}/${DMG_ASSET}"
                  length="${LENGTH}"
                  type="application/octet-stream"
                  sparkle:edSignature="${ED_SIG}"
                />
              </item>
            </channel>
          </rss>
          APPCAST
            sed -i '' 's/^          //' "$OUTFILE"
            echo "Generated $OUTFILE:"
            cat "$OUTFILE"
          }

          generate_appcast "Intel" "Zimi-Intel" "Zimi-Intel.dmg" "appcast-intel.xml"
          generate_appcast "Apple Silicon" "Zimi-AppleSilicon" "Zimi-AppleSilicon.dmg" "appcast-arm64.xml"

          # Commit and push to main
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add appcast-intel.xml appcast-arm64.xml
          git diff --cached --quiet && echo "No appcast changes" || {
            git commit -m "Update appcasts for ${TAG}"
            git push origin main
          }

      - name: Create draft release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.tag || github.ref_name }}
          draft: true
          files: |
            Zimi-Linux-amd64/Zimi-Linux-amd64.AppImage
            Zimi-Linux-snap/*.snap
            Zimi-Intel/Zimi-Intel.dmg
            Zimi-AppleSilicon/Zimi-AppleSilicon.dmg
