name: Desktop Release

on:
  push:
    tags: ['v*.*.*']
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build (e.g. v1.3.0)'
        required: false

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            artifact: Zimi-Linux-amd64
            asset: Zimi-Linux-amd64.AppImage
          - os: macos-15-intel
            artifact: Zimi-Intel
            asset: Zimi-Intel.dmg
          - os: macos-latest
            artifact: Zimi-AppleSilicon
            asset: Zimi-AppleSilicon.dmg
          - os: windows-latest
            artifact: Zimi-Windows-amd64
            asset: Zimi-Windows-amd64.zip

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgirepository-2.0-dev \
            gir1.2-gtk-3.0 \
            gir1.2-webkit2-4.1 \
            gcc libcairo2-dev pkg-config python3-dev

      - name: Set pythonnet runtime (Windows)
        if: runner.os == 'Windows'
        run: echo "PYTHONNET_RUNTIME=coreclr" >> $env:GITHUB_ENV
        shell: pwsh

      - name: Install dependencies
        run: pip install -r requirements-desktop.txt

      - name: Install PyGObject (Linux)
        if: runner.os == 'Linux'
        run: pip install PyGObject

      - name: Install pytest
        run: pip install pytest

      # ── Pre-build tests ──────────────────────────────────────────────

      - name: Run unit tests
        run: python tests/test_unit.py

      - name: Run integration tests
        run: python -m pytest tests/test_server.py -v

      # ── Build ─────────────────────────────────────────────────────────

      - name: Download Sparkle.framework (macOS)
        if: runner.os == 'macOS'
        run: |
          curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz" -o /tmp/sparkle.tar.xz
          cd /tmp && tar -xf sparkle.tar.xz
          cp -R /tmp/Sparkle.framework Sparkle.framework
          echo "Sparkle.framework ready ($(du -sh Sparkle.framework | cut -f1))"

      - name: Generate icons
        run: python assets/generate_icons.py

      - name: Inspect libzim package
        shell: bash
        run: |
          python -c "import libzim; print('libzim OK')"
          python -c "
          import importlib.util, os, sysconfig
          spec = importlib.util.find_spec('libzim')
          print(f'libzim origin: {spec.origin}')
          print(f'submodule_search_locations: {spec.submodule_search_locations}')
          for base in [sysconfig.get_path('purelib'), sysconfig.get_path('platlib')]:
              d = os.path.join(base, 'libzim')
              if os.path.isdir(d):
                  print(f'libzim dir ({d}):')
                  for f in sorted(os.listdir(d)):
                      full = os.path.join(d, f)
                      sz = os.path.getsize(full) if os.path.isfile(full) else '-'
                      print(f'  {f}  ({sz})')
          "

      - name: Build with PyInstaller
        run: pyinstaller --noconfirm zimi_desktop.spec

      - name: Bundle .NET runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Find .NET runtime (6, 7, or 8 — needed by pythonnet/clr_loader)
          $dotnetRoot = (Get-Command dotnet).Source | Split-Path
          Write-Host "dotnet root: $dotnetRoot"
          Write-Host "Available runtimes:"
          dotnet --list-runtimes
          $runtimeDir = Get-ChildItem "$dotnetRoot\shared\Microsoft.NETCore.App" -Directory |
            Sort-Object Name -Descending | Select-Object -First 1
          if (-not $runtimeDir) {
            Write-Error "No .NET runtime found"
            exit 1
          }
          Write-Host "Bundling .NET runtime from: $dotnetRoot"
          $dest = "dist\Zimi\_internal\dotnet_runtime"
          # Copy shared/Microsoft.NETCore.App/{version}/ (CoreCLR runtime)
          $sharedDest = "$dest\shared\Microsoft.NETCore.App\$($runtimeDir.Name)"
          New-Item -ItemType Directory -Force -Path $sharedDest | Out-Null
          Copy-Item "$($runtimeDir.FullName)\*" -Destination $sharedDest -Recurse
          # Copy host/fxr/{version}/ (hostfxr.dll — required by clr_loader)
          $fxrDir = Get-ChildItem "$dotnetRoot\host\fxr" -Directory |
            Sort-Object Name -Descending | Select-Object -First 1
          if ($fxrDir) {
            $fxrDest = "$dest\host\fxr\$($fxrDir.Name)"
            New-Item -ItemType Directory -Force -Path $fxrDest | Out-Null
            Copy-Item "$($fxrDir.FullName)\*" -Destination $fxrDest -Recurse
            Write-Host "Bundled hostfxr from: $($fxrDir.FullName)"
          } else {
            Write-Warning "No hostfxr directory found"
          }
          Write-Host "Bundled $(Get-ChildItem $dest -Recurse -File | Measure-Object | Select-Object -Expand Count) files total"

      # ── Post-build smoke tests ────────────────────────────────────────

      - name: Smoke test built binary (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          BINARY="dist/Zimi.app/Contents/MacOS/Zimi"
          TMPZIM=$(mktemp -d)
          echo "Starting Zimi with --serve --port 0 ..."
          $BINARY --serve --port 0 --zim-dir "$TMPZIM" > /tmp/zimi_out.txt 2>&1 &
          PID=$!

          # Wait for READY message (up to 30s)
          PORT=""
          for i in $(seq 1 60); do
            if grep -q "^READY " /tmp/zimi_out.txt 2>/dev/null; then
              PORT=$(grep "^READY " /tmp/zimi_out.txt | head -1 | awk '{print $2}')
              break
            fi
            sleep 0.5
          done

          if [ -z "$PORT" ]; then
            echo "ERROR: Server did not start within 30s"
            cat /tmp/zimi_out.txt
            kill $PID 2>/dev/null || true
            exit 1
          fi

          echo "Server ready on port $PORT"
          BASE="http://127.0.0.1:$PORT"

          # Hit endpoints
          echo "Testing /health..."
          curl -sf "$BASE/health" | python -c "import sys,json; d=json.load(sys.stdin); assert d['status']=='ok', f'Bad health: {d}'; print(f'  OK: v{d[\"version\"]}, {d[\"zim_count\"]} ZIMs')"

          echo "Testing /list..."
          curl -sf "$BASE/list" | python -c "import sys,json; d=json.load(sys.stdin); print(f'  OK: {len(d)} sources')"

          echo "Testing /search..."
          curl -sf "$BASE/search?q=test&limit=1&fast=1" | python -c "import sys,json; d=json.load(sys.stdin); assert 'results' in d; print(f'  OK: {d[\"total\"]} results')"

          echo "Testing /static/pdfjs/web/viewer.html..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/static/pdfjs/web/viewer.html")
          [ "$STATUS" = "200" ] && echo "  OK: pdf.js viewer" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "Testing /manage/status..."
          curl -sf "$BASE/manage/status" | python -c "import sys,json; d=json.load(sys.stdin); assert 'zim_count' in d; print(f'  OK: {d[\"zim_count\"]} ZIMs, manage={d[\"manage_enabled\"]}')"

          echo "Testing / (web UI)..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/")
          [ "$STATUS" = "200" ] && echo "  OK: web UI" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "All smoke tests passed!"
          kill $PID 2>/dev/null || true
          rm -rf "$TMPZIM"

      - name: Smoke test built binary (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          BINARY="dist/Zimi/Zimi"
          TMPZIM=$(mktemp -d)
          echo "Starting Zimi with --serve --port 0 ..."
          $BINARY --serve --port 0 --zim-dir "$TMPZIM" > /tmp/zimi_out.txt 2>&1 &
          PID=$!

          PORT=""
          for i in $(seq 1 60); do
            if grep -q "^READY " /tmp/zimi_out.txt 2>/dev/null; then
              PORT=$(grep "^READY " /tmp/zimi_out.txt | head -1 | awk '{print $2}')
              break
            fi
            sleep 0.5
          done

          if [ -z "$PORT" ]; then
            echo "ERROR: Server did not start within 30s"
            cat /tmp/zimi_out.txt
            kill $PID 2>/dev/null || true
            exit 1
          fi

          echo "Server ready on port $PORT"
          BASE="http://127.0.0.1:$PORT"

          echo "Testing /health..."
          curl -sf "$BASE/health" | python -c "import sys,json; d=json.load(sys.stdin); assert d['status']=='ok'; print(f'  OK: v{d[\"version\"]}')"

          echo "Testing /static/pdfjs/web/viewer.html..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/static/pdfjs/web/viewer.html")
          [ "$STATUS" = "200" ] && echo "  OK: pdf.js viewer" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "Testing / (web UI)..."
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/")
          [ "$STATUS" = "200" ] && echo "  OK: web UI" || { echo "FAIL: got $STATUS"; exit 1; }

          echo "All smoke tests passed!"
          kill $PID 2>/dev/null || true
          rm -rf "$TMPZIM"

      - name: Smoke test built binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $BINARY = "dist\Zimi\Zimi.exe"
          $TMPZIM = New-TemporaryFile | ForEach-Object { Remove-Item $_; New-Item -ItemType Directory -Path $_ }
          Write-Host "Starting Zimi with --serve --port 0 ..."

          $proc = Start-Process -FilePath $BINARY -ArgumentList "--serve","--port","0","--zim-dir",$TMPZIM.FullName `
            -RedirectStandardOutput "$env:TEMP\zimi_out.txt" -RedirectStandardError "$env:TEMP\zimi_err.txt" `
            -PassThru -NoNewWindow

          $PORT = $null
          for ($i = 0; $i -lt 60; $i++) {
            Start-Sleep -Milliseconds 500
            if (Test-Path "$env:TEMP\zimi_out.txt") {
              $content = Get-Content "$env:TEMP\zimi_out.txt" -ErrorAction SilentlyContinue
              $ready = $content | Where-Object { $_ -match "^READY (\d+)" }
              if ($ready) {
                $PORT = $Matches[1]
                break
              }
            }
          }

          if (-not $PORT) {
            Write-Host "ERROR: Server did not start within 30s"
            Get-Content "$env:TEMP\zimi_out.txt" -ErrorAction SilentlyContinue
            Get-Content "$env:TEMP\zimi_err.txt" -ErrorAction SilentlyContinue
            Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
            exit 1
          }

          Write-Host "Server ready on port $PORT"
          $BASE = "http://127.0.0.1:$PORT"

          Write-Host "Testing /health..."
          $resp = Invoke-RestMethod "$BASE/health"
          if ($resp.status -ne "ok") { Write-Error "Health check failed"; exit 1 }
          Write-Host "  OK: v$($resp.version)"

          Write-Host "Testing /static/pdfjs/web/viewer.html..."
          $r = Invoke-WebRequest "$BASE/static/pdfjs/web/viewer.html" -UseBasicParsing
          if ($r.StatusCode -ne 200) { Write-Error "pdf.js viewer not found"; exit 1 }
          Write-Host "  OK: pdf.js viewer"

          Write-Host "All smoke tests passed!"
          Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
          Remove-Item $TMPZIM.FullName -Recurse -Force -ErrorAction SilentlyContinue

      # ── Packaging ─────────────────────────────────────────────────────

      - name: Package AppImage (Linux)
        if: runner.os == 'Linux'
        run: |
          # Build AppDir from PyInstaller output
          APPDIR=dist/Zimi.AppDir
          mv dist/Zimi "$APPDIR"

          # Add AppImage metadata
          cp linux/AppRun "$APPDIR/"
          chmod +x "$APPDIR/AppRun"
          cp linux/zimi.desktop "$APPDIR/"
          cp assets/icon.png "$APPDIR/zimi.png"
          ln -sf zimi.png "$APPDIR/.DirIcon"

          # Download appimagetool
          curl -sL "https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage" -o /tmp/appimagetool
          chmod +x /tmp/appimagetool

          # Build the AppImage (--appimage-extract-and-run avoids FUSE requirement in CI)
          ARCH=x86_64 /tmp/appimagetool --appimage-extract-and-run "$APPDIR" "${{ matrix.asset }}"

      - name: Install create-dmg (macOS)
        if: runner.os == 'macOS'
        run: brew install create-dmg

      - name: Import signing certificate (macOS)
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE_BASE64 != ''
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -hex 12)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

      - name: Copy Sparkle.framework into app bundle (macOS)
        if: runner.os == 'macOS'
        run: |
          # PyInstaller spec copies Sparkle.framework, but only if it exists at build time.
          # Ensure it's in place for signing (CI downloads it fresh).
          FWDIR="dist/Zimi.app/Contents/Frameworks"
          if [ ! -d "$FWDIR/Sparkle.framework" ] && [ -d "Sparkle.framework" ]; then
            mkdir -p "$FWDIR"
            cp -R Sparkle.framework "$FWDIR/"
            echo "Copied Sparkle.framework to Frameworks/"
          else
            echo "Sparkle.framework already in place"
          fi

      - name: Code sign app (macOS)
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE_BASE64 != ''
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Use whatever signing identity is in the keychain
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | head -1 | sed 's/.*"\(.*\)"/\1/')
          echo "Signing with: $IDENTITY"

          # Sign Sparkle.framework's nested binaries first
          SPARKLE="dist/Zimi.app/Contents/Frameworks/Sparkle.framework"
          if [ -d "$SPARKLE" ]; then
            # Sign Autoupdate (XPC service inside Sparkle)
            find "$SPARKLE" -type f \( -name "*.xpc" -o -name "Autoupdate" -o -name "Updater" \) -exec \
              codesign --force --options runtime --sign "$IDENTITY" --timestamp {} \;
            # Sign the framework binary itself
            codesign --force --options runtime --sign "$IDENTITY" --timestamp "$SPARKLE/Versions/Current/Sparkle"
            codesign --force --options runtime --sign "$IDENTITY" --timestamp "$SPARKLE"
          fi

          # Sign all binaries inside the app bundle
          find dist/Zimi.app -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.pyd" \) -exec \
            codesign --force --options runtime --sign "$IDENTITY" --timestamp {} \;

          # Sign the main executable
          codesign --force --options runtime --sign "$IDENTITY" --timestamp dist/Zimi.app/Contents/MacOS/Zimi

          # Sign the app bundle itself
          codesign --force --deep --options runtime --sign "$IDENTITY" --timestamp dist/Zimi.app

          # Verify
          codesign --verify --deep --strict dist/Zimi.app
          echo "Code signing successful"

      - name: Package (macOS)
        if: runner.os == 'macOS'
        working-directory: dist
        run: |
          create-dmg \
            --volname "Zimi" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "Zimi.app" 150 185 \
            --app-drop-link 450 185 \
            --no-internet-enable \
            ../${{ matrix.asset }} Zimi.app

      - name: Notarize DMG (macOS)
        if: runner.os == 'macOS' && env.APPLE_ID != ''
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Submitting for notarization..."
          xcrun notarytool submit ${{ matrix.asset }} \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait --timeout 10m

          echo "Waiting for notarization ticket to propagate..."
          sleep 15

          echo "Stapling notarization ticket..."
          for i in 1 2 3; do
            xcrun stapler staple ${{ matrix.asset }} && break
            echo "Staple attempt $i failed, retrying in 15s..."
            sleep 15
          done
          echo "Notarization complete"

      - name: Package (Windows)
        if: runner.os == 'Windows'
        working-directory: dist
        shell: pwsh
        run: Compress-Archive -Path Zimi -DestinationPath ../${{ matrix.asset }}

      - name: Move asset to dist
        run: mv ${{ matrix.asset }} dist/ 2>/dev/null || true
        shell: bash

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: dist/${{ matrix.asset }}

  release:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Create draft release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.tag || github.ref_name }}
          draft: true
          files: |
            Zimi-Linux-amd64/Zimi-Linux-amd64.AppImage
            Zimi-Intel/Zimi-Intel.dmg
            Zimi-AppleSilicon/Zimi-AppleSilicon.dmg
            Zimi-Windows-amd64/Zimi-Windows-amd64.zip
