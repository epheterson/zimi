# Release Process

## Pre-release

- [ ] All changes on a feature branch (e.g. `v1.4`), NOT on `main`
- [ ] Unit tests pass: `python3 tests/test_unit.py`
- [ ] Integration tests pass: `python3 -m pytest tests/test_server.py -v`
- [ ] README updated (features, endpoints, screenshots)
- [ ] Deployed and verified on NAS
- [ ] Screenshots current

## Release (two-phase)

**Phase 1: Build + Draft**

- [ ] Squash feature branch to single commit
- [ ] Open PR from feature branch → `main`
- [ ] Review PR diff
- [ ] Merge PR on GitHub
- [ ] Pull main locally: `git checkout main && git pull`
- [ ] Tag: `git tag v1.X.0`
- [ ] Push tag: `git push origin v1.X.0`
- [ ] CI builds, runs tests, creates **draft** release with artifacts
- [ ] Verify CI passed: `gh run list --repo epheterson/Zimi --limit 3`

**Phase 2: Manual QA → Publish**

Before publishing a draft release, verify on real hardware:

- [ ] Download macOS DMG (Apple Silicon or Intel, whichever you have)
- [ ] Install app, launch with real ZIM files
- [ ] Verify search works across multiple sources
- [ ] Verify PDF viewer opens zimgit PDFs in reader (not externally)
- [ ] Verify article navigation history (click links within articles)
- [ ] Verify back button steps through history, then closes reader
- [ ] Verify desktop title bar syncs with article titles
- [ ] Verify catalog browse, download flow, and update check
- [ ] Test on clean install (delete `~/.config/zimi/` or equivalent first)
- [ ] (Optional) Linux: download AppImage, `chmod +x Zimi-Linux-amd64.AppImage`, run `./Zimi-Linux-amd64.AppImage --serve`

When QA passes:

- [ ] Publish draft release (GitHub → Releases → Edit → Publish)
- [ ] Docker Hub multi-arch build runs automatically on published tag

## Post-release

- [ ] Verify Docker Hub image: `docker pull epheterson/zimi:latest`
- [ ] Update PLAN.md (mark release complete, start next version section)
- [ ] Sync to vault: `cp zimi.py ~/vault/infra/zim-reader/ && cp templates/index.html ~/vault/infra/zim-reader/templates/`

## Desktop App Build

### Prerequisites

```bash
pip install -r requirements-desktop.txt
# Installs: libzim, PyMuPDF, pywebview, Pillow, pyinstaller
```

### Generate icons (if changed)

```bash
python assets/generate_icons.py
# Creates: assets/icon.png, assets/icon.ico, assets/icon.icns
# Requires: Pillow. Uses SF Compact Black on macOS for the Z glyph.
```

### Build .app (macOS)

```bash
pyinstaller --noconfirm zimi_desktop.spec
# Output: dist/Zimi.app (~115 MB)
# Test:   open dist/Zimi.app
```

### Build on other platforms

```bash
# Windows → dist/Zimi/ folder (zip for distribution)
pyinstaller --noconfirm zimi_desktop.spec

# Linux → dist/Zimi/ folder (tar.gz for distribution)
pyinstaller --noconfirm zimi_desktop.spec
```

### Create DMG (macOS distribution)

```bash
hdiutil create -volname Zimi -srcfolder dist/Zimi.app -ov -format UDZO dist/Zimi.dmg
# Or with create-dmg for a fancy installer: brew install create-dmg
# create-dmg --volname "Zimi" --no-internet-enable dist/Zimi.dmg dist/Zimi.app
```

### GitHub Actions

The `.github/workflows/desktop-release.yml` workflow builds for macOS, Windows, and Linux automatically when a `v*.*.*` tag is pushed. It:

1. Runs unit tests and integration tests (pre-build)
2. Builds with PyInstaller
3. Runs smoke tests against the built binary using `--serve` flag
4. Creates a **draft** GitHub Release with artifacts

Release artifacts:
- `Zimi-AppleSilicon.dmg` and `Zimi-Intel.dmg` (macOS)
- `Zimi-Windows-amd64.zip` (Windows)
- `Zimi-Linux-amd64.AppImage` (Linux)

After manual QA, publish the draft to make it visible to users.

### macOS Code Signing + Notarization

Requires an Apple Developer account ($99/yr). One-time setup:

**1. Export your certificate:**
- Open Keychain Access
- Find "Developer ID Application: Your Name (TEAMID)"
- Right-click → Export → save as `certificate.p12` (set a password)

**2. Add GitHub repo secrets** (Settings → Secrets and variables → Actions):

| Secret | Value |
|--------|-------|
| `APPLE_CERTIFICATE_BASE64` | `base64 -i certificate.p12 \| pbcopy` (paste result) |
| `APPLE_CERTIFICATE_PASSWORD` | Password you set when exporting .p12 |
| `APPLE_TEAM_ID` | 10-char team ID from developer.apple.com → Membership |
| `APPLE_ID` | Your Apple ID email |
| `APPLE_APP_PASSWORD` | App-specific password from appleid.apple.com → Sign-In and Security → App-Specific Passwords |
| `SPARKLE_PRIVATE_KEY` | Sparkle EdDSA private key (generated by `bin/generate_keys` from Sparkle distribution, exported with `-x`) |
| `HOMEBREW_TAP_TOKEN` | Fine-grained PAT with repo access to `epheterson/homebrew-zimi` (for auto-updating the Homebrew cask on release) |

**3. The workflow handles the rest:**
- Imports certificate into a temporary keychain
- Downloads Sparkle.framework and embeds it in the .app
- `codesign --deep --force --options runtime` on the .app bundle (including Sparkle)
- `xcrun notarytool submit` + `xcrun stapler staple` on the DMG
- Result: users double-click, it just works. No Gatekeeper warnings.

**4. On release publish (draft → published):**
- Signs DMGs with Sparkle EdDSA key
- Updates `appcast.xml` on main branch (Sparkle auto-update feed)
- Updates `homebrew-zimi` cask with new version + SHA256 hashes

### Gotchas

- `dist/` and `build/` are gitignored — never commit build artifacts
- PyInstaller COPY's source at build time — rebuild after code changes
- The `.spec` file includes `templates/` and `assets/` as data files
- macOS: the BUNDLE section creates the `.app` with proper `Info.plist` (CFBundleName=Zimi, icon, bundle ID)
- The `_set_macos_app_identity()` function in `zimi_desktop.py` is a fallback for dev mode (`python zimi_desktop.py`) but the proper .app build handles Dock icon/name natively via Info.plist
- Windows build needs a Windows machine or VM (cross-compilation not supported by PyInstaller)

## Rules

- **Never commit directly to `main`** — always use feature branches + PRs
- **Never push to `main`** — merge via GitHub PR
- **Squash before merging** — one clean commit per release
- **Tag after merge** — tag on main, not on the feature branch
- **Docker Hub after tag** — ensures the image matches the tagged code
